;;;
;;; A few rudimentary Owl-specific tests
;;;

(define (time-thunk thunk)
	(lets 
		((ss ms (clock))
		 (start (+ ms (* ss 1000)))
		 (val (thunk))
		 (ss ms (clock))
		 (elapsed (- (+ ms (* ss 1000)) start)))
		elapsed))

(define-syntax time
	(syntax-rules ()
		((time op) (time-thunk (λ () op)))))

(define (test name thunk elems unit framework)
	(lets ((elapsed (max 0 (- (time-thunk thunk) framework))))
		(print* (list name " (" elems "): " elapsed "ms (" (if (= elapsed 0) 'inf (div elems elapsed)) " " unit ")"))
      elapsed))

(define (now) (lets ((ss ms (clock))) (+ ms (* ss 1000))))

(import lib-iff)
(begin
;   (define d (iota 0 1 10000))
;   (define s (test "blank run" (λ () (fold (λ (ff n) n) #f d)) 30000 "n/ms" 0))
;   (test "ff inorder construction" (λ () (fold (λ (ff n) (put ff n n)) #f d)) 30000 "n/ms" s)
;   (define d (random-numbers (now) 64 30000))
;   (define s (test "blank run" (λ () (fold (λ (ff n) n) #f d)) 30000 "n/ms" 0))
;   (test "ff random write 64 " (λ () (fold (λ (ff n) (put ff n n)) #f d)) 30000 "n/ms")
;   (define d (random-numbers (now) 256 30000))
;   (test "ff random write 256 " (λ () (fold (λ (ff n) (put ff n n)) #f d)) 30000 "n/ms")
;   (define d (random-numbers (now) 4096 30000))
;   (test "ff random write 4065 " (λ () (fold (λ (ff n) (put ff n n)) #f d)) 30000 "n/ms")
;   (define d (random-numbers (now) 65535 30000))
;   (test "ff random write 65535 " (λ () (fold (λ (ff n) (put ff n n)) #f d)) 30000 "n/ms")
;
;	;(test "iota" (λ () (iota 0 1 1000)) 1000 "n/ms")
;	;(test "iota" (λ () (iota 0 1 10000)) 10000 "n/ms")
;	(test "iota" (λ () (iota 0 1 100000)) 100000 "n/ms")
;	(test "iota" (λ () (iota 0 1 100000)) 100000 "n/ms")
;	(test "iota" (λ () (iota 0 1 100000)) 100000 "n/ms")
;
;	;(define d (iota 0 1 1000))
;	;(test "rev" (λ () (reverse d)) 1000 "n/ms")
;	;(define d (iota 0 1 10000))
;	;(test "rev" (λ () (reverse d)) 10000 "n/ms")
;	(define d (iota 0 1 100000))
;	(test "rev" (λ () (reverse d)) 100000 "n/ms")
;	(test "rev" (λ () (reverse d)) 100000 "n/ms")
;	(test "rev" (λ () (reverse d)) 100000 "n/ms")
;
;	;(define d (iota 0 1 1000))
;	;(test "fold" (λ () (fold (λ (o n) o) 0 d)) 1000 "n/ms")
;	;(define d (iota 0 1 10000))
;	;(test "fold" (λ () (fold (λ (o n) o) 0 d)) 10000 "n/ms")
	(define d (iota 0 1 100000))
	(test "fold" (λ () (fold (λ (o n) o) 0 d)) 100000 "n/ms" 0)
	(test "fold" (λ () (fold (λ (o n) o) 0 d)) 100000 "n/ms" 0)
	(test "fold" (λ () (fold (λ (o n) o) 0 d)) 100000 "n/ms" 0)

;	(define d (liota 0 1 10000))
;	(test "lazy iota fold" (λ () (fold (λ (o n) o) 0 d)) 10000 "n/ms")
;	(test "lazy iota fold" (λ () (fold (λ (o n) o) 0 d)) 10000 "n/ms")
;	(test "lazy iota fold" (λ () (fold (λ (o n) o) 0 d)) 10000 "n/ms")
;	;(define d (liota 0 1 100000))
;	;(test "lazy iota fold" (λ () (fold (λ (o n) o) 0 d)) 100000 "n/ms")
;	;(test "lazy iota fold" (λ () (fold (λ (o n) o) 0 d)) 100000 "n/ms")
;
;	(define (walk l s)
;		(if (null? l)
;			s
;			(walk (cdr l) (car l))))
;	(define d (iota 0 1 100000))
;	(test "walk" (λ () (walk d 0)) 100000 "n/ms")
;	(test "walk" (λ () (walk d 0)) 100000 "n/ms")
;	(test "walk" (λ () (walk d 0)) 100000 "n/ms")
;
;	(define d (lets ((lst (iota 0 1 10000))) (list->ff (zip cons lst lst))))
;	(test "ff-fold" (λ () (ff-fold (λ (o k n) o) 0 d)) 10000 "n/ms")
;	(test "ff-fold" (λ () (ff-fold (λ (o k n) o) 0 d)) 10000 "n/ms")
;	(test "ff-fold" (λ () (ff-fold (λ (o k n) o) 0 d)) 10000 "n/ms")
;	;(define d (lets ((lst (iota 0 1 100000))) (list->ff (zip cons lst lst))))
;	;(test "ff-fold" (λ () (ff-fold (λ (o k n) o) 0 d)) 100000 "n/ms")
;	;(test "ff-fold" (λ () (ff-fold (λ (o k n) o) 0 d)) 100000 "n/ms")
;	;(test "ff-fold" (λ () (ff-fold (λ (o k n) o) 0 d)) 100000 "n/ms")

	(define d (list->vector (iota 0 1 50000)))
	(test "vec-fold" (λ () (fold (λ (o n) o) 0 d)) 50000 "n/ms" 0)
	(test "vec-fold" (λ () (fold (λ (o n) o) 0 d)) 50000 "n/ms" 0)
	(test "vec-fold" (λ () (fold (λ (o n) o) 0 d)) 50000 "n/ms" 0)
	;(define d (list->vector (iota 0 1 100000)))
	;(test "vec-fold" (λ () (fold (λ (o n) o) 0 d)) 100000 "n/ms")
	;(test "vec-fold" (λ () (fold (λ (o n) o) 0 d)) 100000 "n/ms")

   (define (vec-walk vec)
      (let ((end (vec-len vec)))
         (let loop ((p 0))
            (if (= p end)
               null
               (pair (vec-ref vec p)
                  (loop (+ p 1)))))))

	(define i (iota 0 1 50000))
	(define d (list->vector i))
	(test "vec-walk-fold" (λ () (fold (λ (o n) o) 0 (vec-walk d))) 50000 "n/ms" 0)
	(test "vec-walk-fold" (λ () (fold (λ (o n) o) 0 (vec-walk d))) 50000 "n/ms" 0)
	(test "vec-walk-fold" (λ () (fold (λ (o n) o) 0 (vec-walk d))) 50000 "n/ms" 0)

	(define i (iota 0 1 50000))
	(define d (list->vector i))
	(test "vec-ref-fold" (λ () (fold (λ (o n) (vec-ref d n)) 0 i)) 50000 "n/ms" 0)
	(test "vec-ref-fold" (λ () (fold (λ (o n) (vec-ref d n)) 0 i)) 50000 "n/ms" 0)
	(test "vec-ref-fold" (λ () (fold (λ (o n) (vec-ref d n)) 0 i)) 50000 "n/ms" 0)

;	;(define i (iota 0 1 100000))
;	;(define d (list->vector i))
;	;(test "vec-ref-fold" (λ () (fold (λ (o n) (vec-ref d n)) 0 i)) 100000 "n/ms")
;	;(test "vec-ref-fold" (λ () (fold (λ (o n) (vec-ref d n)) 0 i)) 100000 "n/ms")
;
;	(define i (iota 0 1 10000))
;	(define d (fold (λ (iff n) (iput iff n n)) #f i))
;	(test "iff get" (λ () (fold (λ (o n) (iget d n #f)) 0 i)) 10000 "n/ms")
;	(test "iff get" (λ () (fold (λ (o n) (iget d n #f)) 0 i)) 10000 "n/ms")
;	;(define i (iota 0 1 100000))
;	;(define d (fold (λ (iff n) (iput iff n n)) #f i))
;	;(test "iff get" (λ () (fold (λ (o n) (iget d n #f)) 0 i)) 100000 "n/ms")
;	;(test "iff get" (λ () (fold (λ (o n) (iget d n #f)) 0 i)) 100000 "n/ms")
;	;(define i (iota 0 1 1000000))
;	;(define d (fold (λ (iff n) (iput iff n n)) #f i))
;	;(test "iff get" (λ () (fold (λ (o n) (iget d n #f)) 0 i)) 1000000 "n/ms")
;	;(test "iff get" (λ () (fold (λ (o n) (iget d n #f)) 0 i)) 1000000 "n/ms")
;
;   (define n-nums 200)
;   (define n-pairs (expt n-nums 2))
;   (define nums16 (random-numbers 1234124124124 #x10000 n-nums))
;   (define nums32 (random-numbers 1231231231233 #x100000000 n-nums))
;   (define nums64 (random-numbers 1231231231233 #x10000000000000000 n-nums))
;   (define nums128 (random-numbers 1231231231233 #x100000000000000000000000000000000 n-nums))
;
;   (define (k a b) a)
;   (define blank
;      (div
;         (fold + 0
;            (list
;               (test "number blank run" (λ () (for-each (λ (a) (for-each (λ (b) (k a b)) nums16)) nums16)) n-pairs "n/ms" 0)
;               (test "number blank run" (λ () (for-each (λ (a) (for-each (λ (b) (k a b)) nums16)) nums16)) n-pairs "n/ms" 0)
;               (test "number blank run" (λ () (for-each (λ (a) (for-each (λ (b) (k a b)) nums16)) nums16)) n-pairs "n/ms" 0)
;               (test "number blank run" (λ () (for-each (λ (a) (for-each (λ (b) (k a b)) nums16)) nums16)) n-pairs "n/ms" 0)))
;         4))
;
;   (show " - average blank run " blank)
;
;   (print "--- a R b ---")
;   (test "blank  a _ b " (λ () (for-each (λ (a) (for-each (λ (b) b) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a + b " (λ () (for-each (λ (a) (for-each (λ (b) (+ a b)) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a * b " (λ () (for-each (λ (a) (for-each (λ (b) (* a b)) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a - b " (λ () (for-each (λ (a) (for-each (λ (b) (- a b)) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a = b " (λ () (for-each (λ (a) (for-each (λ (b) (= a b)) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a < b " (λ () (for-each (λ (a) (for-each (λ (b) (< a b)) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a > b " (λ () (for-each (λ (a) (for-each (λ (b) (> a b)) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a ediv b " (λ () (for-each (λ (a) (for-each (λ (b) (div a b)) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a rem b " (λ () (for-each (λ (a) (for-each (λ (b) (rem a b)) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a div b " (λ () (for-each (λ (a) (for-each (λ (b) (div a b)) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a gcd b " (λ () (for-each (λ (a) (for-each (λ (b) (gcd a b)) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a / b " (λ () (for-each (λ (a) (for-each (λ (b) (/ a b)) nums16)) nums16)) n-pairs "n/ms" blank)
;
;   (print "--- a R B ---")
;   (test "blank  a _ b " (λ () (for-each (λ (a) (for-each (λ (b) b) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number a + B " (λ () (for-each (λ (a) (for-each (λ (b) (+ a b)) nums32)) nums16)) n-pairs "n/ms" blank)
;   (test "number a * B " (λ () (for-each (λ (a) (for-each (λ (b) (* a b)) nums32)) nums16)) n-pairs "n/ms" blank)
;   (test "number a - B " (λ () (for-each (λ (a) (for-each (λ (b) (- a b)) nums32)) nums16)) n-pairs "n/ms" blank)
;   (test "number a = B " (λ () (for-each (λ (a) (for-each (λ (b) (= a b)) nums32)) nums16)) n-pairs "n/ms" blank)
;   (test "number a < B " (λ () (for-each (λ (a) (for-each (λ (b) (< a b)) nums32)) nums16)) n-pairs "n/ms" blank)
;   (test "number a > B " (λ () (for-each (λ (a) (for-each (λ (b) (> a b)) nums32)) nums16)) n-pairs "n/ms" blank)
;   (test "number a ediv B " (λ () (for-each (λ (a) (for-each (λ (b) (ediv a b)) nums32)) nums16)) n-pairs "n/ms" blank)
;   (test "number a rem B " (λ () (for-each (λ (a) (for-each (λ (b) (rem a b)) nums32)) nums16)) n-pairs "n/ms" blank)
;   (test "number a div B " (λ () (for-each (λ (a) (for-each (λ (b) (div a b)) nums32)) nums16)) n-pairs "n/ms" blank)
;   (test "number a gcd B " (λ () (for-each (λ (a) (for-each (λ (b) (gcd a b)) nums32)) nums16)) n-pairs "n/ms" blank)
;   (test "number a / B " (λ () (for-each (λ (a) (for-each (λ (b) (/ a b)) nums32)) nums16)) n-pairs "n/ms" blank)
;
;   (print "--- A R B ---")
;   (test "blank  a _ b " (λ () (for-each (λ (a) (for-each (λ (b) b) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number A + B " (λ () (for-each (λ (a) (for-each (λ (b) (+ a b)) nums32)) nums32)) n-pairs "n/ms" blank)
;   (test "number A * B " (λ () (for-each (λ (a) (for-each (λ (b) (* a b)) nums32)) nums32)) n-pairs "n/ms" blank)
;   (test "number A - B " (λ () (for-each (λ (a) (for-each (λ (b) (- a b)) nums32)) nums32)) n-pairs "n/ms" blank)
;   (test "number A = B " (λ () (for-each (λ (a) (for-each (λ (b) (= a b)) nums32)) nums32)) n-pairs "n/ms" blank)
;   (test "number A < B " (λ () (for-each (λ (a) (for-each (λ (b) (< a b)) nums32)) nums32)) n-pairs "n/ms" blank)
;   (test "number A > B " (λ () (for-each (λ (a) (for-each (λ (b) (> a b)) nums32)) nums32)) n-pairs "n/ms" blank)
;   (test "number A ediv B " (λ () (for-each (λ (a) (for-each (λ (b) (ediv a b)) nums32)) nums32)) n-pairs "n/ms" blank)
;   (test "number A rem B " (λ () (for-each (λ (a) (for-each (λ (b) (rem a b)) nums32)) nums32)) n-pairs "n/ms" blank)
;   (test "number A div B " (λ () (for-each (λ (a) (for-each (λ (b) (div a b)) nums32)) nums32)) n-pairs "n/ms" blank)
;   (test "number A gcd B " (λ () (for-each (λ (a) (for-each (λ (b) (gcd a b)) nums32)) nums32)) n-pairs "n/ms" blank)
;   (test "number A / B " (λ () (for-each (λ (a) (for-each (λ (b) (/ a b)) nums32)) nums32)) n-pairs "n/ms" blank)
;
;   (print "--- A R B 64 ---")
;   (test "blank  a _ b " (λ () (for-each (λ (a) (for-each (λ (b) b) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number A + B " (λ () (for-each (λ (a) (for-each (λ (b) (+ a b)) nums64)) nums64)) n-pairs "n/ms" blank)
;   (test "number A * B " (λ () (for-each (λ (a) (for-each (λ (b) (* a b)) nums64)) nums64)) n-pairs "n/ms" blank)
;   (test "number A - B " (λ () (for-each (λ (a) (for-each (λ (b) (- a b)) nums64)) nums64)) n-pairs "n/ms" blank)
;   (test "number A = B " (λ () (for-each (λ (a) (for-each (λ (b) (= a b)) nums64)) nums64)) n-pairs "n/ms" blank)
;   (test "number A < B " (λ () (for-each (λ (a) (for-each (λ (b) (< a b)) nums64)) nums64)) n-pairs "n/ms" blank)
;   (test "number A > B " (λ () (for-each (λ (a) (for-each (λ (b) (> a b)) nums64)) nums64)) n-pairs "n/ms" blank)
;   (test "number A ediv B " (λ () (for-each (λ (a) (for-each (λ (b) (ediv a b)) nums64)) nums64)) n-pairs "n/ms" blank)
;   (test "number A rem B " (λ () (for-each (λ (a) (for-each (λ (b) (rem a b)) nums64)) nums64)) n-pairs "n/ms" blank)
;   (test "number A div B " (λ () (for-each (λ (a) (for-each (λ (b) (div a b)) nums64)) nums64)) n-pairs "n/ms" blank)
;   (test "number A gcd B " (λ () (for-each (λ (a) (for-each (λ (b) (gcd a b)) nums64)) nums64)) n-pairs "n/ms" blank)
;   (test "number A / B " (λ () (for-each (λ (a) (for-each (λ (b) (/ a b)) nums64)) nums64)) n-pairs "n/ms" blank)
;
;   (print "--- A R B 128 ---")
;   (test "blank  a _ b " (λ () (for-each (λ (a) (for-each (λ (b) b) nums16)) nums16)) n-pairs "n/ms" blank)
;   (test "number A + B " (λ () (for-each (λ (a) (for-each (λ (b) (+ a b)) nums128)) nums128)) n-pairs "n/ms" blank)
;   (test "number A * B " (λ () (for-each (λ (a) (for-each (λ (b) (* a b)) nums128)) nums128)) n-pairs "n/ms" blank)
;   (test "number A - B " (λ () (for-each (λ (a) (for-each (λ (b) (- a b)) nums128)) nums128)) n-pairs "n/ms" blank)
;   (test "number A = B " (λ () (for-each (λ (a) (for-each (λ (b) (= a b)) nums128)) nums128)) n-pairs "n/ms" blank)
;   (test "number A < B " (λ () (for-each (λ (a) (for-each (λ (b) (< a b)) nums128)) nums128)) n-pairs "n/ms" blank)
;   (test "number A > B " (λ () (for-each (λ (a) (for-each (λ (b) (> a b)) nums128)) nums128)) n-pairs "n/ms" blank)
;   (test "number A ediv B " (λ () (for-each (λ (a) (for-each (λ (b) (ediv a b)) nums128)) nums128)) n-pairs "n/ms" blank)
;   (test "number A rem B " (λ () (for-each (λ (a) (for-each (λ (b) (rem a b)) nums128)) nums128)) n-pairs "n/ms" blank)
;   (test "number A div B " (λ () (for-each (λ (a) (for-each (λ (b) (div a b)) nums128)) nums128)) n-pairs "n/ms" blank)
;   (test "number A gcd B " (λ () (for-each (λ (a) (for-each (λ (b) (gcd a b)) nums128)) nums128)) n-pairs "n/ms" blank)
;   (test "number A / B " (λ () (for-each (λ (a) (for-each (λ (b) (/ a b)) nums128)) nums128)) n-pairs "n/ms" blank)
	)
